//
//  GenerateFrontend.swift
//  SFSymbolsGenerator
//
//  Created by Joshua Asbury on 24/2/2024.
//

import Files
import Foundation
import SwiftRepresentation

class GenerateFrontend {
    enum Constants {
        static let resourceStructName = "SFSymbolResource"
        static let systemNameProperty = "systemName"
    }
    
    /// A set of all language codes, used to determine if the last segment of a symbol is a language code.
    private static let isoLanguageCodes = Set(Locale.LanguageCode.isoLanguageCodes.map(\.identifier))
    
    private let symbolNames: [String]
    
    private let accessModifier: AccessModifier
    
    private let safeNameGenerator: any SafeNameGenerator = .idiomatic
    
    private let declarationMutators: [any DeclarationMutator]

    private init(resourceFolder resources: Folder,
                 accessModifier: AccessModifier,
                 safeNameGenerator: any SafeNameGenerator,
                 exportLocalizationOptions: LocalizationOption) throws {
        let decoder = PropertyListDecoder()

        func readFile<T>(_ filename: String, to type: T.Type) throws -> T where T: Decodable {
            let file = try resources.file(named: filename)
            let data = try file.read()
            var format: PropertyListSerialization.PropertyListFormat = .openStep
            return try decoder.decode(T.self, from: data, format: &format)
        }

        let nameAvailability = try readFile("name_availability.plist", to: NameAvailability.self)
        let symbolRestrictions = try readFile("symbol_restrictions.strings", to: [String: String].self)
        let nameAliases = try readFile("name_aliases.strings", to: [String: String].self)
        
        self.symbolNames = Self.symbolNames(Array(nameAvailability.symbols.keys), applying: exportLocalizationOptions, with: symbolRestrictions)
        self.accessModifier = accessModifier
        self.declarationMutators = [
            AvailabilityMutator(nameAvailability: nameAvailability),
            DeprecationMutator(nameAliases: nameAliases),
            RestrictionMutator(symbolRestrictions: symbolRestrictions),
        ]
    }

    convenience init(accessModifier: AccessModifier,
                     safeNameGenerator: any SafeNameGenerator,
                     exportLocalizationOptions: LocalizationOption) throws {
        let resources = try Folder(path: "/System/Library/PrivateFrameworks/SFSymbols.framework/Versions/A/Resources/CoreGlyphs.bundle/Contents/Resources")
        try self.init(
            resourceFolder: resources,
            accessModifier: accessModifier,
            safeNameGenerator: safeNameGenerator,
            exportLocalizationOptions: exportLocalizationOptions
        )
    }

    func run() throws {
        let generatedFile = FileDescription(
            topComment: .inline("Generated by sfsymbolsgenerator, do not modify."),
            imports: [
                ImportDescription(moduleName: "Foundation"),
            ],
            codeBlocks: [
                .declaration(systemNameStruct()),
                .declaration(sfSymbolResourceStaticPropertiesExtension(symbolNames))
            ]
        )
        
        let representation = StructuredSwiftRepresentation(file: .init(name: "fileName", contents: generatedFile))
        
        let diagnostics = ErrorThrowingDiagnosticCollector(upstream: StdErrPrintingDiagnosticCollector())
        let file = try TextBasedRenderer.default.render(structured: representation, diagnostics: diagnostics)
        
        print(String(data: file.contents, encoding: .utf8) ?? "<error>")
    }
    
    func systemNameStruct() -> Declaration {
        .commentable(
            .doc("An SFSymbol resource."),
            .struct(StructDescription(
                accessModifier: accessModifier,
                name: Constants.resourceStructName,
                conformances: ["Hashable"],
                members: [
                    .commentable(
                        .doc("An SFSymbol system name."),
                        .variable(
                            accessModifier: accessModifier,
                            kind: .let,
                            left: Constants.systemNameProperty,
                            type: .init(TypeName.string)
                        )
                    ),
                    .commentable(
                        .functionComment(
                            abstract: "Initialize a `\(Constants.resourceStructName)` with `\(Constants.systemNameProperty)`.",
                            parameters: [
                                ("name", "The SFSymbol system name.")
                            ]
                        ),
                        .function(
                            accessModifier: .fileprivate,
                            kind: .initializer,
                            parameters: [
                                .init(label: Constants.systemNameProperty,
                                      name: "name",
                                      type: .init(TypeName.string))
                            ],
                            body: [
                                .expression(.assignment(
                                    left: .selfDot(Constants.systemNameProperty),
                                    right: .identifierPattern("name")
                                ))
                            ]
                        )
                    )
                ]
            ))
        )
    }
    
    func performMutation(_ declaration: Declaration,
                         for symbolName: String) -> Declaration {
        declarationMutators.reduce(into: declaration) { declaration, mutator in
            mutator.mutate(&declaration, for: symbolName)
        }
    }
    
    func sfSymbolResourceStaticPropertiesExtension(_ symbolNames: [String]) -> Declaration {
        let symbolDeclarations = symbolNames.compactMap { symbolName in
            let propertyDeclaration = transformSymbolNameToStaticProperty(symbolName)
            return performMutation(propertyDeclaration, for: symbolName)
        }
        
        return .extension(
            accessModifier: accessModifier,
            onType: Constants.resourceStructName,
            declarations: symbolDeclarations
        )
    }
    
    func transformSymbolNameToStaticProperty(_ symbolName: String) -> Declaration {
        .commentable(
            .doc(#"The "\#(symbolName)" SFSymbol."#),
            .variable(
                accessModifier: accessModifier,
                isStatic: true,
                kind: .var,
                left: .identifierPattern(safeNameGenerator.swiftMemberName(for: symbolName)),
                type: .member(Constants.resourceStructName),
                getter: [
                    .expression(
                        .functionCall(
                            calledExpression: .identifierPattern(Constants.resourceStructName),
                            arguments: [.init(
                                label: Constants.systemNameProperty,
                                expression: .literal(symbolName)
                            )]
                        )
                    )
                ]
            )
        )
    }
    
//
//        let source = try SourceFileSyntax {
//            try canImportUIKit {
//                availabilityHeaderUIKit {
//                    """
//                    extension UIKit.UIImage {
//                        /// Initialize a `UIImage` with a SFSymbol resource.
//                        convenience init(systemSymbolResource resource: SFSymbolResource) {
//                            self.init(systemName: resource.name)!
//                        }
//                    }
//                    """
//                }
//
//                try availabilityHeaderUIKit {
//                    try ExtensionDeclSyntax("extension UIKit.UIImage") {
//                        for propertyName in symbolsNames {
//                            """
//
//
//                            /// The \(literal: propertyName) SF Symbol.
//                            ///
//                            /// \(raw: symbolRestrictions[propertyName].map { "- Important: \($0)" } ?? " ")
//                            @available(\(availabilityOfSymbol(propertyName)))
//                            static var \(raw: propertyName.asIdentifier): UIKit.UIImage {
//                                UIKit.UIImage(systemSymbolResource: .\(raw: propertyName.asIdentifier))
//                            }
//                            """
//                        }
//                    }
//                }
//            }
//        }
    
    static func symbolNames(_ symbolNames: [String],
                            applying exportLocalizationOptions: LocalizationOption,
                            with symbolRestrictions: [String: String]) -> [String] {
        var symbolNames = symbolNames
        
        if !exportLocalizationOptions.contains(.languageCode) {
            symbolNames.removeAll(where: Self.hasLanguageCode(_:))
        }
        if !exportLocalizationOptions.contains(.rightToLeft) {
            symbolNames.removeAll(where: Self.hasRightToLeftSpecifier(_:))
        }
        
        let restrictedSymbols = symbolNames.filter { symbolRestrictions[$0] != nil }
        symbolNames = Array(symbolNames)
        symbolNames.append(contentsOf: restrictedSymbols)
        return symbolNames.sorted()
    }

    static func hasLanguageCode(_ value: String) -> Bool {
        if let lastSegment = value.split(separator: ".").last {
            return isoLanguageCodes.contains(String(lastSegment))
        }
        return false
    }

    static func hasRightToLeftSpecifier(_ value: String) -> Bool {
        value.hasSuffix(".rtl")
    }
}

struct MetadataError: LocalizedError {
    let errorDescription: String?

    init(reason: String) {
        errorDescription = reason
    }
}
